--- module-init-tools-3.2.2/modinfo.c	2005-01-18 05:25:23.000000000 +0200
+++ module-init-tools-3.4/modinfo.c	2007-10-08 00:51:46.000000000 +0300
@@ -272,7 +272,8 @@
 	return (char *)end + 1;
 }
 
-static void *grab_module(const char *name, unsigned long *size, char**filename)
+static void *grab_module(const char *name, unsigned long *size, char**filename,
+	const char *kernel)
 {
 	char *data;
 	struct utsname buf;
@@ -290,8 +291,13 @@
 	}
 
 	/* Search for it in modules.dep. */
-	uname(&buf);
-	asprintf(&depname, "%s/%s/modules.dep", MODULE_DIR, buf.release);
+	if (kernel) {
+		asprintf(&depname, "%s/%s/modules.dep", MODULE_DIR, kernel);
+	} else {
+		uname(&buf);
+		asprintf(&depname, "%s/%s/modules.dep", MODULE_DIR,
+			 buf.release);
+	}
 	data = grab_file(depname, size);
 	if (!data) {
 		fprintf(stderr, "modinfo: could not open %s\n", depname);
@@ -322,7 +328,7 @@
 
 static void usage(const char *name)
 {
-	fprintf(stderr, "Usage: %s [-0][-F field] module...\n"
+	fprintf(stderr, "Usage: %s [-0][-F field][-k kernelversion] module...\n"
 		" Prints out the information about one or more module(s).\n"
 		" If a fieldname is given, just print out that field (or nothing if not found).\n"
 		" Otherwise, print all information out in a readable form\n"
@@ -334,6 +340,7 @@
 {
 	union { short s; char c[2]; } endian_test;
 	const char *field = NULL;
+	const char *kernel = NULL;
 	char sep = '\n';
 	unsigned long infosize;
 	int opt, ret = 0;
@@ -347,7 +354,7 @@
 	else
 		abort();
 
-	while ((opt = getopt_long(argc,argv,"adlpVhn0F:",options,NULL)) >= 0){
+	while ((opt = getopt_long(argc,argv,"adlpVhn0F:k:",options,NULL)) >= 0){
 		switch (opt) {
 		case 'a': field = "author"; break;
 		case 'd': field = "description"; break;
@@ -357,6 +364,7 @@
 		case 'V': printf(PACKAGE " version " VERSION "\n"); exit(0);
 		case 'F': field = optarg; break;
 		case '0': sep = '\0'; break;
+		case 'k': kernel = optarg; break;
 		default:
 			usage(argv[0]); exit(0);
 		}
@@ -369,10 +377,10 @@
 		unsigned long modulesize;
 		char *filename;
 
-		mod = grab_module(argv[opt], &modulesize, &filename);
+		mod = grab_module(argv[opt], &modulesize, &filename, kernel);
 		if (!mod) {
 			ret = 1;
 			continue;
 		}
 
 		info = get_section(mod, modulesize, &infosize, ".modinfo");
